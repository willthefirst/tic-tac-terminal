#!/usr/bin/env node

// todo: prevent bad coords/already taken spots
// todo: allow to restart a new game

const chalk = require("chalk");
const readline = require("readline");
const args = process.argv;

const gameState = {
    currentPlayer: "X",
    board: [
        ["_", "_", "_"],
        ["_", "_", "_"],
        ["_", "_", "_"],
    ],
};

// Set up readline
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: "",
});

/**
* Prints usage instructions.
*/
const printUsage = function () {
    const instructions = `
    Tic Tac Toe (by Will Moritz)
    
    usage: 
    
    tic-tac-toe <command>
    
    commands can be:
    start:    start a new game
    help:     show instructions
    `;
    
    console.log(instructions);
};

/**
* Prints current board state
*/
function showBoard() {
    let result = ``;
    
    for (let i = 0; i < gameState.board.length; i++) {
        const row = gameState.board[i];
        let rowString = `   `;
        for (let j = 0; j < row.length; j++) {
            const cell = row[j];
            rowString = rowString + cell + " ";
        }
        result = result + rowString + "\n";
    }
    
    console.log(chalk.green(result));
}

/**
* Starts a new game
*/
const start = function () {
    promptMove();
};

/**
* Checks board for three in a row.
* Looks at the row and column of the current move, then both diagonals.
* @param  {number} xCoord
* @param  {number} yCoord
*/
function noWinner(xCoord, yCoord) {
    const board = gameState.board;
    
    // Check current row
    if (board[yCoord].every(isCurrentPlayer)) {
        return false;
    }
    
    // Check current column
    const currColumn = [];
    
    for (let i = 0; i < board.length; i++) {
        currColumn.push(board[i][xCoord]);
    }
    
    if (currColumn.every(isCurrentPlayer)) {
        return false;
    }
    
    // Check diagonals
    const diagonals = [
        [board[0][0], board[1][1], board[2][2]],
        [board[0][2], board[1][1], board[2][0]],
    ];
    
    for (let i = 0; i < diagonals.length; i++) {
        if (diagonals[i].every(isCurrentPlayer)) {
            return false;
        }
    }
    
    return true;
}

function isCurrentPlayer(cell) {
    return cell === gameState.currentPlayer;
}

/**
 * Switches players
 */
function switchPlayer() {
    if (gameState.currentPlayer === "X") {
        gameState.currentPlayer = "O";
    } else {
        gameState.currentPlayer = "X";
    }
}

/**
 * Prompts user for coordinates and saves to gameState
 */
const promptMove = function () {    
    showBoard();
    
    console.log(`${gameState.currentPlayer}'s turn:\n`);
    rl.question("Enter X coordinate for your move: ", (x) => {
        rl.question("Enter Y coordinate for your move: ", (y) => {
            console.log("");

            if (!coordinatesAreValid(x, y)) {
                promptMove();
                return;
            }

            gameState.board[y][x] = gameState.currentPlayer;

            if (noWinner(x, y)) {
                switchPlayer();
                promptMove();
            } else {
                declareWinner();
            }
        });
    });
};

/**
 * Returns false if coordinates are invalid or already occupied
 * @param {number} x - Attempted move's X coordinate
 * @param {number} y - Attempted move's Y coordinate
 */
function coordinatesAreValid(x, y) {
    if (x < 0 || x > 2 || y < 0 || y > 2) {
        console.error(chalk.red("Coordinates are invalid.\n"));
        return false;
    } else if (gameState.board[y][x] !== "_") {
        console.error(chalk.red("You may not play that position. Try again.\n"))
        return false;
    } else {
        return true;
    }
}

/**
 * Prints out winner and closes game connection
 */
function declareWinner() {
    showBoard();
    console.log(`${gameState.currentPlayer} has won! Game over.`);
    rl.close();
}

/**
* Initializes interactive console.
*/
const init = function () {
    const commands = {
        start: start,
        help: printUsage,
    };
    
    printUsage();
    start();
    
    // // Listen for user input
    // rl.on("line", (input) => {
    //     input = input.toLowerCase();
    //     if (input in commands) {
    //         commands[input]();
    //     } else {
    //         console.log(`Invalid argument: ${input}`);
    //     }
    // });
};

init();
